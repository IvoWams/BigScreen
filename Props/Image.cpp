#include "Image.h"
#include <gl/gl.h>
#include <gl/glu.h>
#include <global/Globals.h>
#include <texture/TextureHandler.h>
#include <sdl/sdl.h>
#include <sdl/sdl_image.h>
#include <fstream>

Image::Image(const string& filename, double left, double top) : RootObject(){
	engine = Globals::getGlobals()->engine;
	
//	fout.open("image.txt", ios::out | ios::app);
//	fout << "Starting\n";
//	fout << "file " << filename << "\n";
//	fout.flush();

	position->x	= left;
	position->y	= top;
	
	flat = true;
	order = 4;
	
	// Grab image data for this image
	imagedata	= ImageDataHandler::getImageDataHandler()->getImageData(filename);
	
	// Grab texture
	texture = engine->getTextureHandler()->getTexture(filename);
//	fout << "imagedata: " << imagedata << "\n";
//	fout << "dib: " << imagedata->dib << "\n";
//	fout << "available: " << imagedata->available << "\n";
//	fout.flush();
	
	
	// If there is DIB info, and no previous errors have occured, and no imagedata
	// has been processed yet, load the DIB info in our texture. DIB info is generated by
	// the PreLoader.
	
	if(imagedata->dib && imagedata->available){
//		fout << "Binding to texture\n";
//		fout.flush();
		// Binding to opengl texture ID we reserved
		glBindTexture(GL_TEXTURE_2D, texture->glref);

		glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
		glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR_MIPMAP_LINEAR);

		// Autoadjust
		string ext = filename.substr(filename.size()-3,3);
		
		if(ext == "bmp" || ext == "tga")
			gluBuild2DMipmaps(	GL_TEXTURE_2D, 
								imagedata->dib->format->BytesPerPixel,
								imagedata->dib->w,
								imagedata->dib->h,
								0x80E0,			// Inverse: BGR
//								GL_RGB,
								GL_UNSIGNED_BYTE,
								imagedata->dib->pixels
							);

		else if(ext == "png")

			gluBuild2DMipmaps(	GL_TEXTURE_2D, 
								imagedata->dib->format->BytesPerPixel,
								imagedata->dib->w,
								imagedata->dib->h,
//								0x80E0,			// Inverse: BGR
								GL_RGBA,
								GL_UNSIGNED_BYTE,
								imagedata->dib->pixels
							);

			else
		
			gluBuild2DMipmaps(	GL_TEXTURE_2D, 
								imagedata->dib->format->BytesPerPixel,
								imagedata->dib->w,
								imagedata->dib->h,
								GL_RGB,
								GL_UNSIGNED_BYTE,
								imagedata->dib->pixels
							);

		texture->available = true;
		SDL_FreeSurface(imagedata->dib);
		imagedata->dib = NULL;
	}

	// No errors? set image dimensions to sizes
	if(!imagedata->error){	
		width		= imagedata->width;
		height		= imagedata->height;
	}
}

Image::~Image(){}

void	Image::paint(){
	if(!imagedata->available)return;
	if(isBlinked())return;
	if(!visible)return;
	
	glLoadIdentity();
	glTranslatef(position->x, position->y, 0);

	glTranslatef(0.5*width, 0.5*height, 0);
    glScalef(scale->x, scale->y, scale->z);

    glRotatef(rotation->x, 1, 0, 1);
    glRotatef(rotation->y, 0, 1, 0);
    glRotatef(rotation->z, 0, 0, 1);

    glTranslatef(-0.5*width, -0.5*height, 0);

	glColor4f(color->R,color->G,color->B,color->A);

	glDisable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glDisable(GL_COLOR_MATERIAL);
	
	glBindTexture(GL_TEXTURE_2D, texture->glref);

	glBegin (GL_QUADS);
	glTexCoord2f(0, 0);
	glVertex3f ( 0, 0, 0);
	glTexCoord2f(1, 0);
	glVertex3f ( width, 0, 0);
	glTexCoord2f(1, 1);
	glVertex3f ( width, height, 0);
	glTexCoord2f(0, 1);
	glVertex3f ( 0, height, 0);
	glEnd ();
}
